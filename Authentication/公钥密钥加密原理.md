[公钥密钥加密原理](https://www.jianshu.com/p/0bf1c3c047e5)
1.1 基础知识
密钥：一般就是一个字符串或数字，在加密或者解密时传递给加密/解密算法。
对称加密算法：加密和解密都是使用的同一个密钥。因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开。
非对称加密算法：加密使用的密钥和解密使用的密钥是不同的。 公钥密码体制就是一种非对称加密算法。
(1) 公钥密码体制
分为三个部分：公钥、私钥、加密/解密算法

加密解密过程如下：
加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。
解密：通过解密算法和私钥对密文进行解密，得到明文。

注意：由公钥加密的内容，只能由私钥进行解密。

公钥密码体制的公钥和算法都是公开的，私钥是保密的。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。

(2) RSA加密算法
一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。

(3) 签名
就是在信息的后面再加上一段内容，可以证明信息没有被修改过。

一般是对信息做一个hash计算得到一个hash值（该过程不可逆），在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。 接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。

当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。

1.2 基于RSA算法的加密通信的例子
“客户”->“服务器”：你好
“服务器”->“客户”：你好，我是服务器
“客户”->“服务器”：向我证明你就是服务器
“服务器”->“客户”：你好，我是服务器{你好，我是服务器}[私钥|RSA]
“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]
“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]
“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]
“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]

总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：
1. 因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。
2. 客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。

但是这里还留有一个问题，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？
我们可能会想到以下的两个方法：
a) 把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。
b) 每次和“客户”开始通信时，“服务器”把公钥发给“客户”。

但是这个两个方法都有一定的问题，
对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个
地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。
对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他
自己的私钥就可以冒充“服务器”了。示意如下：

“客户”->“黑客”：你好 //黑客截获“客户”发给“服务器”的消息
“黑客”->“客户”：你好，我是服务器，这个是我的公钥 //黑客自己生成一对公钥和私钥，把
公钥发给“客户”，自己保留私钥
“客户”->“黑客”：向我证明你就是服务器
“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA] //客户收到

“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

1.3 数字证书
为了解决上述问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：

证书的发布机构
证书的有效期
证书所有者（Subject）
公钥
指纹和指纹算法
签名算法
指纹和指纹算法
这个是用来保证证书的完整性的，也就是说确保证书没有被修改过。 其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。
注意，这个指纹会用"SecureTrust CA"这个证书机构的私钥用签名算法加密后和证书放在一起。

签名算法
就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名

数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：

“客户”->“服务器”：你好
“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 //这里用证书代替了公钥
“客户”->“服务器”：向我证明你就是服务器
“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。

如何向证书的发布机构去申请证书

举个例子，假设我们公司"ABC Company"花了1000块钱，向一个证书发布机构"SecureTrust CA"为我们自己的公司"ABC Company"申请了一张证书，注意，这个证书发布机构"SecureTrust CA"是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了"SecureTrust CA"的证书。"SecureTrust CA"在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时"SecureTrust CA"还会给一个我们公司"ABC Company"的私钥给到我们。
我们"ABC Company"申请到这个证书后，我们把证书投入使用，我们在通信过程开始时会把证书发给对方。

对方如何检查这个证书的确是合法的并且是我们"ABC Company"公司的证书呢？首先应用程序(对方通信用的程序，例如IE、OUTLook等)读取证书中的Issuer(发布机构)为"SecureTrust CA" ，然后会在操作系统中受信任的发布机构的证书中去找"SecureTrust CA"的证书，如果找不到，那说明证书的发布机构是个水货发布机构，证书可能有问题，程序会给出一个错误信息。 如果在系统中找到了"SecureTrust CA"的证书，那么应用程序就会从证书中取出"SecureTrust CA"的公钥，然后对我们"ABC Company"公司的证书里面的指纹和指纹算法用这个公钥进行解密，然后使用这个指纹算法计算"ABC Company"证书的指纹，将这个计算的指纹与放在证书中的指纹对比，如果一致，说明"ABC Company"的证书肯定没有被修改过并且证书是"SecureTrust CA" 发布的，证书中的公钥肯定是"ABC Company"的。对方然后就可以放心的使用这个公钥和我们"ABC Company"进行通信了。

作者：AndroidMaster
链接：https://www.jianshu.com/p/0bf1c3c047e5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。